# см про self в 2_0_classmethods&self.py
# но зачем интерпретатор self автоматически добавляет: чтобы мы могли работать с локальными атрибутами конкретного экземпляра класса
# т.е создается много разных экземпляров pt1, pt2, pt3 одного и того же класса Point, то этот метод set_coords не копируется в отдельные экземпляры
# этот метод как был в классе так и остается, и только благодаря self мы знаем с каким экземпляром класса в данный момент работает этот метод set_coords
# и через него можно создавать или менять локальные свойства экземпляра класса 

class Point:
    color = 'red'
    circle = 2

    def set_coords(self, x, y):
        self.x = x
        self.y = y

    def get_coords(self):
        return (self.x, self.y)

pt = Point()
pt2 = Point()

pt.set_coords(1,2)
pt2.set_coords(10,20)

#print(pt.__dict__)
#print(pt2.__dict__)

print(pt.get_coords())

# имена методов - это тоже аттрибуты класса

f = getattr(pt, 'get_coords')
print(f) # f ссылается на связанный метод с классом Point
print(f()) # а значит можем его вызвать (но так почти не делают, в основном через точку)

print(None)
