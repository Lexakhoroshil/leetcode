class Point:
    def __new__(cls, *args, **kwards):
        print("вызов __new__ для " + str(cls))
        return super().__new__(cls) 
# super - это ссылка на базовый класс , и из базового класса вызываем такой же метод new и передаем ссылку cls на текущий класс point
# откуда базовый класс? Начиная с python3 все классы автоматически и неявно наследуются от такого базового класса object:
# def __new__(cls):...

# т.е при вызове super() в Point то получаем ссылку на базовый класс и в этом базовом классе уже вызываем магический метод _new_
# и этот магический метод запускает уже процесс создания класса и возвращает адрес нового созданного объекта
# ну а мы с помощью оператора. return возвращаем уже этот адрес дальше


    def __init__(self, x=0, y=0):
        print("вызов __init__ для " + str(self))
        self.x = x
        self.y = y


#pt = Point(1,2)


#print(pt) # теперь уже был вызов и new и __init и теперь pt ведет на экзеппляр класса

# аргументы  *args, **kwards - мы хоть и не используем, но прописывать нужно - они автоматичски передаются в метод new
# зачем же нужен __new__?
# ответ: паттерн Singleton:
## пример с подключением к БД - класс DataBase и далее полагаем что в программе должен существовать только один экземпляр этого класса
## db = DataBase('login', 'password', 80) , но он должен быть только один
## те при создании db2 = DataBase('login2', 'password', 80) - вот эта ссылка должна вести на тот же самый экзепляр (db)

# реализуем паттерн Singleton в нашей программе и пропишем этот класс

class DataBase:
    __instance = None # __instance - ссылка на экземпляр класса

    def __new__(cls, *args, **kwards):
        if cls.__instance is None:
            cls.__instance = super().__new__(cls)
        return cls.__instance 
# и тут выше как раз получается, что если экзепляра нет, мы его создаем, а если есть то возращаем адрес ранее созданного объекта
# и таким образом контролим что у нас в программе существует ровно 1 объект 

# пропишем еще финализатор
    def __del__(self):
        DataBase.__instance = None
# т.е если объект был удален сборщиком мусора, то аттрибут класса DataBase __instance снова будет None и мы сможем повторно создать этот обеъкт класса

    def __init__(self, user, psw, port):
        self.user = user
        self.psw = psw
        self.port = port

    def connect(self):
        print(f"соединение с БД: {self.user}, {self.psw}, {self.port}")

    def close(self):
        print(f"закрытие соединения с БД")
    
    def read(self):
        return "даные из БД"
    
    def write(self, data):
        print(f"запись в БД {data}")


db = DataBase('user1', 'pwd', 80)
db2 = DataBase('user2', 'pwd2', 40)

print(id(db), id(db2))

# у них айдишники одинаковые - т.е при создании второго объекта он ен был создан и вот эта bd2 ссылается на ранее созданный объект
# однако локальные свойсвта db меняются на локальные свойства db2
# чтобы это поправить нужно переопределить еще один магический метод __call__

print(None)