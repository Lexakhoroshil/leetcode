# Механизм инкапсуляции 

# attribute - публичное свойство (public)
# _attribute - режим доступа protected (служит для обращения внутри класса и во всех его дочерних классах)
# __attribute - режим доступа private (служит для обращения только внутри класса)

class Point:
    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y

pt = Point(1,2)

# если не использовать _ и __ при определении переменных, то
# значения можно менять через ссылку pt:

pt.x = 200
pt.y = "coord y"

print(pt.x, pt.y) # будут уже не 1,2 а 200 и "coord y"



# _attribute 

class Point:
    def __init__(self, x=0, y=0):
        self._x = x
        self._y = y

# вроде как извне мы никак не можем к ним обратиться ОДНАКО:
pt = Point(1,2)

pt._x = 200
pt._y = "coord y"

print(pt._x, pt._y) # видно, что и обратиться можно и изменить
# дело в том, что в Python вот это _ лишь сигнализирует программисту, что данные свойства являются защищенными, НО ЯВНО НИКАК НЕ ОГРАНИЧИВАЕТ ДОСТУП К НЕМУ ИЗВНЕ
# _ лишь предостерегает программиста, что не предполагается использование этого аттрибута вне класса и впоследствие это можнет стать причиной ошибок
# например изменится версия класса и этот аттрибут с _ перестанет существовать, так как никто не предполагал, что будет использование его вовне



# __attribute 

class Point:
    def __init__(self, x=0, y=0):
        self.__x = x
        self.__y = y

#pt = Point(1,2)
#print(pt.__x, pt.__y) # тут будет ошибка

### пропишем set_coord

class Point:
    def __init__(self, x=0, y=0):
        self.__x = x
        self.__y = y

    def set_coord(self, x,y):
        self.__x = x
        self.__y = y

pt = Point(1,2)

pt.set_coord(10,20) # отработало - значит внутри класса можем обращаться



### пропишем get_coord
class Point:
    def __init__(self, x=0, y=0):
        self.__x = x
        self.__y = y

    def set_coord(self, x,y):

        # добавим сюда еще проверку
        if type(x) in (int, float) and type(y) in (int, float):
            self.__x = x
            self.__y = y
        # сеттер помимо того что обновляет локальные свойства внутри экземпляра класса, то есть приватные локальные свойства, так он еще добавляет
        # проверку на допустимость значений
        else:
            raise ValueError("Координаты должны быть числами")

    def get_coord(self):
        return self.__x, self.__y


pt = Point(1,2)
pt.set_coord(10,20)
print(pt.get_coord())


pt.set_coord('10',20) # всплывет ошибка
print(pt.get_coord())

# вот эти методы set_coord и get_coord называют "геттеры и сеттеры" или интерфейсные методы

# класс в ООП следует воспринимать как единое целое, и чтобы случайно или намеренно не нарушить целостность работы алгоритма внутри этого класса,
# то следует взаимодействовать с ним только через публичные свойства и методы
# в этом как раз суть принципа инкапсуляции

print(None)

# далее совершенствуем класс Ponit в 6_1